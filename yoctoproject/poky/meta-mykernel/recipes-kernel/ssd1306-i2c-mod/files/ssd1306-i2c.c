/*
 * SSD1306 I2C Character Device Driver
 * Author: HUNGPK
 * Description: I2C character device driver for SSD1306 OLED display (128x64)
 */

#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/of.h>
#include <linux/fs.h>
#include <linux/kernel.h>

#define SSD1306_COMM_CONTROL_BYTE 0x00
#define SSD1306_DATA_CONTROL_BYTE 0x40

#define SSD1306_COMM_DISPLAY_OFF 0xAE
#define SSD1306_COMM_DISPLAY_ON 0xAF
#define SSD1306_COMM_HORIZ_NORM 0xA0
#define SSD1306_COMM_HORIZ_FLIP 0xA1
#define SSD1306_COMM_RESUME_RAM 0xA4
#define SSD1306_COMM_IGNORE_RAM 0xA5
#define SSD1306_COMM_DISP_NORM 0xA6
#define SSD1306_COMM_DISP_INVERSE 0xA7
#define SSD1306_COMM_MULTIPLEX 0xA8
#define SSD1306_COMM_VERT_OFFSET 0xD3
#define SSD1306_COMM_CLK_SET 0xD5
#define SSD1306_COMM_PRECHARGE 0xD9
#define SSD1306_COMM_COM_PIN 0xDA
#define SSD1306_COMM_DESELECT_LV 0xDB
#define SSD1306_COMM_CONTRAST 0x81
#define SSD1306_COMM_DISABLE_SCROLL 0x2E
#define SSD1306_COMM_ENABLE_SCROLL 0x2F
#define SSD1306_COMM_PAGE_NUMBER 0xB0
#define SSD1306_COMM_LOW_COLUMN 0x00
#define SSD1306_COMM_HIGH_COLUMN 0x10

#define SSD1306_COMM_START_LINE 0x40
#define SSD1306_COMM_CHARGE_PUMP 0x8D
#define SSD1306_COMM_SCAN_NORM 0xC0
#define SSD1306_COMM_SCAN_REVS 0xC8
#define SSD1306_COMM_MEMORY_MODE 0x20
#define SSD1306_COMM_SET_COL_ADDR 0x21
#define SSD1306_COMM_SET_PAGE_ADDR 0x22

#define SSD1306_HORI_MODE 0x00
#define SSD1306_VERT_MODE 0x01
#define SSD1306_PAGE_MODE 0x02

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define SCREEN_PAGES (SCREEN_HEIGHT / 8)

#define FONT_WIDTH 8

#define MAX_STRING_LEN 128

struct ssd1306_par
{
    struct i2c_client *client;
    struct miscdevice miscdev;
};

static const u8 font8x8[95][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // <space>
    {0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00}, // !
    {0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00}, // "
    {0x00, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x00}, // #
    {0x00, 0x2E, 0x2A, 0x7F, 0x2A, 0x3A, 0x00, 0x00}, // $
    {0x00, 0x46, 0x26, 0x10, 0x08, 0x64, 0x62, 0x00}, // %
    {0x00, 0x20, 0x54, 0x4A, 0x54, 0x20, 0x50, 0x00}, // &
    {0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00}, // '
    {0x00, 0x00, 0x00, 0x3C, 0x42, 0x00, 0x00, 0x00}, // (
    {0x00, 0x00, 0x00, 0x42, 0x3C, 0x00, 0x00, 0x00}, // )
    {0x00, 0x10, 0x54, 0x38, 0x54, 0x10, 0x00, 0x00}, // *
    {0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00}, // +
    {0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00}, // ,
    {0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, // .
    {0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00}, // /
    {0x3C, 0x62, 0x52, 0x4A, 0x46, 0x3C, 0x00, 0x00}, // 0
    {0x44, 0x42, 0x7E, 0x40, 0x40, 0x00, 0x00, 0x00}, // 1
    {0x64, 0x52, 0x52, 0x52, 0x52, 0x4C, 0x00, 0x00}, // 2
    {0x24, 0x42, 0x42, 0x4A, 0x4A, 0x34, 0x00, 0x00}, // 3
    {0x30, 0x28, 0x24, 0x7E, 0x20, 0x20, 0x00, 0x00}, // 4
    {0x2E, 0x4A, 0x4A, 0x4A, 0x4A, 0x32, 0x00, 0x00}, // 5
    {0x3C, 0x4A, 0x4A, 0x4A, 0x4A, 0x30, 0x00, 0x00}, // 6
    {0x02, 0x02, 0x62, 0x12, 0x0A, 0x06, 0x00, 0x00}, // 7
    {0x34, 0x4A, 0x4A, 0x4A, 0x4A, 0x34, 0x00, 0x00}, // 8
    {0x0C, 0x52, 0x52, 0x52, 0x52, 0x3C, 0x00, 0x00}, // 9
    {0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00}, // :
    {0x00, 0x00, 0x80, 0x64, 0x00, 0x00, 0x00, 0x00}, // ;
    {0x00, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // <
    {0x00, 0x28, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00}, // =
    {0x00, 0x00, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00}, // >
    {0x00, 0x04, 0x02, 0x02, 0x52, 0x0A, 0x04, 0x00}, // ?
    {0x00, 0x3C, 0x42, 0x5A, 0x56, 0x5A, 0x1C, 0x00}, // @
    {0x7C, 0x12, 0x12, 0x12, 0x12, 0x7C, 0x00, 0x00}, // A
    {0x7E, 0x4A, 0x4A, 0x4A, 0x4A, 0x34, 0x00, 0x00}, // B
    {0x3C, 0x42, 0x42, 0x42, 0x42, 0x24, 0x00, 0x00}, // C
    {0x7E, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00}, // D
    {0x7E, 0x4A, 0x4A, 0x4A, 0x4A, 0x42, 0x00, 0x00}, // E
    {0x7E, 0x0A, 0x0A, 0x0A, 0x0A, 0x02, 0x00, 0x00}, // F
    {0x3C, 0x42, 0x42, 0x52, 0x52, 0x34, 0x00, 0x00}, // G
    {0x7E, 0x08, 0x08, 0x08, 0x08, 0x7E, 0x00, 0x00}, // H
    {0x00, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x00, 0x00}, // I
    {0x30, 0x40, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x00}, // J
    {0x7E, 0x08, 0x08, 0x14, 0x22, 0x40, 0x00, 0x00}, // K
    {0x7E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00}, // L
    {0x7E, 0x04, 0x08, 0x08, 0x04, 0x7E, 0x00, 0x00}, // M
    {0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00}, // N
    {0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00}, // O
    {0x7E, 0x12, 0x12, 0x12, 0x12, 0x0C, 0x00, 0x00}, // P
    {0x3C, 0x42, 0x52, 0x62, 0x42, 0x3C, 0x00, 0x00}, // Q
    {0x7E, 0x12, 0x12, 0x12, 0x32, 0x4C, 0x00, 0x00}, // R
    {0x24, 0x4A, 0x4A, 0x4A, 0x4A, 0x30, 0x00, 0x00}, // S
    {0x02, 0x02, 0x02, 0x7E, 0x02, 0x02, 0x02, 0x00}, // T
    {0x3E, 0x40, 0x40, 0x40, 0x40, 0x3E, 0x00, 0x00}, // U
    {0x1E, 0x20, 0x40, 0x40, 0x20, 0x1E, 0x00, 0x00}, // V
    {0x3E, 0x40, 0x20, 0x20, 0x40, 0x3E, 0x00, 0x00}, // W
    {0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00}, // X
    {0x02, 0x04, 0x08, 0x70, 0x08, 0x04, 0x02, 0x00}, // Y
    {0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x00, 0x00}, // Z
    {0x00, 0x00, 0x7E, 0x42, 0x42, 0x00, 0x00, 0x00}, // [
    {0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00}, // <backslash>
    {0x00, 0x00, 0x42, 0x42, 0x7E, 0x00, 0x00, 0x00}, // ]
    {0x00, 0x08, 0x04, 0x7E, 0x04, 0x08, 0x00, 0x00}, // ^
    {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00}, // _
    {0x3C, 0x42, 0x99, 0xA5, 0xA5, 0x81, 0x42, 0x3C}, // `
    {0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00}, // a
    {0x00, 0x7E, 0x48, 0x48, 0x48, 0x30, 0x00, 0x00}, // b
    {0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x00, 0x00}, // c
    {0x00, 0x30, 0x48, 0x48, 0x48, 0x7E, 0x00, 0x00}, // d
    {0x00, 0x38, 0x54, 0x54, 0x54, 0x48, 0x00, 0x00}, // e
    {0x00, 0x00, 0x00, 0x7C, 0x0A, 0x02, 0x00, 0x00}, // f
    {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0xA4, 0x7C, 0x00}, // g
    {0x00, 0x7E, 0x08, 0x08, 0x08, 0x70, 0x00, 0x00}, // h
    {0x00, 0x00, 0x00, 0x48, 0x7A, 0x40, 0x00, 0x00}, // i
    {0x00, 0x00, 0x40, 0x80, 0x80, 0x7A, 0x00, 0x00}, // j
    {0x00, 0x7E, 0x18, 0x24, 0x40, 0x00, 0x00, 0x00}, // k
    {0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x00, 0x00}, // l
    {0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x00, 0x00}, // m
    {0x00, 0x7C, 0x04, 0x04, 0x04, 0x78, 0x00, 0x00}, // n
    {0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00}, // o
    {0x00, 0xFC, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00}, // p
    {0x00, 0x18, 0x24, 0x24, 0x24, 0xFC, 0x80, 0x00}, // q
    {0x00, 0x00, 0x78, 0x04, 0x04, 0x04, 0x00, 0x00}, // r
    {0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00}, // s
    {0x00, 0x00, 0x04, 0x3E, 0x44, 0x40, 0x00, 0x00}, // t
    {0x00, 0x3C, 0x40, 0x40, 0x40, 0x3C, 0x00, 0x00}, // u
    {0x00, 0x0C, 0x30, 0x40, 0x30, 0x0C, 0x00, 0x00}, // v
    {0x00, 0x3C, 0x40, 0x38, 0x40, 0x3C, 0x00, 0x00}, // w
    {0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00}, // x
    {0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C, 0x00, 0x00}, // y
    {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00}, // z
    {0x00, 0x08, 0x08, 0x76, 0x42, 0x42, 0x00, 0x00}, // {
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // |
    {0x00, 0x42, 0x42, 0x76, 0x08, 0x08, 0x00, 0x00}, // }
    {0x00, 0x00, 0x04, 0x02, 0x04, 0x02, 0x00, 0x00}  // ~
};

static int ssd1306_set_cursor(struct i2c_client *client, u8 col, u8 page)
{
    if (col >= SCREEN_WIDTH || page >= SCREEN_PAGES)
        return -EINVAL;

    u8 cmds[] = {
        SSD1306_COMM_CONTROL_BYTE,
        SSD1306_COMM_PAGE_NUMBER + page,
        SSD1306_COMM_LOW_COLUMN + (col & 0x0F),
        SSD1306_COMM_HIGH_COLUMN + ((col >> 4) & 0x0F)
    };

    int ret = i2c_master_send(client, cmds, ARRAY_SIZE(cmds));
    if (ret != ARRAY_SIZE(cmds)) {
        dev_err(&client->dev, "Failed to set cursor: %d\n", ret);
        return ret < 0 ? ret : -EIO;
    }
    return 0;
}

static int ssd1306_clear_display(struct i2c_client *client)
{
    int ret;
    u8 page;
    u8 tmp_buf[SCREEN_WIDTH + 1] = { SSD1306_DATA_CONTROL_BYTE };

    for (page = 0; page < SCREEN_PAGES; page++) {
        ret = ssd1306_set_cursor(client, 0, page);
        if (ret) {
            dev_err(&client->dev, "Failed to set cursor for clear: %d\n", ret);
            return ret;
        }

        ret = i2c_master_send(client, tmp_buf, SCREEN_WIDTH + 1);
        if (ret != SCREEN_WIDTH + 1) {
            dev_err(&client->dev, "Failed to clear display: %d\n", ret);
            return ret < 0 ? ret : -EIO;
        }
    }

    return 0;
}

static int ssd1306_init_display(struct i2c_client *client)
{
    u8 cmds[] = {
        SSD1306_COMM_CONTROL_BYTE,                   // Command control byte
        SSD1306_COMM_DISPLAY_OFF,                    // Display off
        SSD1306_COMM_DISP_NORM,                      // Normal display
        SSD1306_COMM_CLK_SET, 0x80,                  // Clock divide ratio
        SSD1306_COMM_MULTIPLEX, 63,                  // Height = 64
        SSD1306_COMM_VERT_OFFSET, 0,                 // No offset
        SSD1306_COMM_START_LINE,                     // Start line
        SSD1306_COMM_CHARGE_PUMP, 0x14,              // Charge pump
        SSD1306_COMM_MEMORY_MODE, SSD1306_PAGE_MODE, // Page mode
        SSD1306_COMM_HORIZ_FLIP,                     // Segment remap
        SSD1306_COMM_SCAN_REVS,                      // COM scan direction
        SSD1306_COMM_COM_PIN, 0x12,                  // COM pins for 64 lines
        SSD1306_COMM_CONTRAST, 0x7F,                 // Contrast
        SSD1306_COMM_PRECHARGE, 0xF1,                // Precharge
        SSD1306_COMM_DESELECT_LV, 0x40,              // VCOMH deselect
        SSD1306_COMM_RESUME_RAM,                     // Resume RAM
        SSD1306_COMM_DISP_NORM,                      // Normal display
        SSD1306_COMM_DISPLAY_ON,                     // Display on
        SSD1306_COMM_DISABLE_SCROLL                  // Stop scroll
    };

    int ret = i2c_master_send(client, cmds, ARRAY_SIZE(cmds));
    if (ret != ARRAY_SIZE(cmds))
    {
        dev_err(&client->dev, "Failed to send init commands\n");
        return ret < 0 ? ret : -EIO;
    }

    // Clear display
    ret = ssd1306_clear_display(client);
    if (ret != 0) {
        return ret;
    }

    return 0;
}

static ssize_t ssd1306_write(struct file *file, const char __user *buf,
                             size_t count, loff_t *ppos)
{
    struct miscdevice *miscdev = file->private_data;
    struct ssd1306_par *par = container_of(miscdev, struct ssd1306_par, miscdev);
    char *str;
    int ret;
    u8 col = 0, page = 0; // Local cursor position
    u8 buffer[SCREEN_WIDTH + 1] = { SSD1306_DATA_CONTROL_BYTE }; // Buffer for one page
    size_t buffer_idx = 1; // Start after control byte
    size_t i;

    if (count > MAX_STRING_LEN)
        count = MAX_STRING_LEN;

    str = kmalloc(count + 1, GFP_KERNEL);
    if (!str)
        return -ENOMEM;

    if (copy_from_user(str, buf, count)) {
        kfree(str);
        return -EFAULT;
    }
    str[count] = '\0';

    // Clear display
    ret = ssd1306_clear_display(par->client);
    if (ret) {
        kfree(str);
        return ret;
    }

    for (i = 0; i < count && str[i] != '\0' && page < SCREEN_PAGES; i++) {
        char c = str[i];

        // Handle newline or page wrap
        if (c == '\n' || col + FONT_WIDTH > SCREEN_WIDTH) {
            if (buffer_idx > 1) {
                ret = ssd1306_set_cursor(par->client, 0, page);
                if (ret) {
                    kfree(str);
                    return ret;
                }
                ret = i2c_master_send(par->client, buffer, buffer_idx);
                if (ret != (int)buffer_idx) {
                    dev_err(&par->client->dev, "Failed to send buffer: %d\n", ret);
                    kfree(str);
                    return ret < 0 ? ret : -EIO;
                }
                buffer_idx = 1;
            }

            col = 0;
            page++;
            if (c == '\n')
                continue;
        }

        // Replace invalid characters with space
        if (c < 32 || c > 126)
            c = 32;

        // Add character to buffer
        memcpy(&buffer[buffer_idx], font8x8[c - 32], FONT_WIDTH);
        buffer_idx += FONT_WIDTH;
        col += FONT_WIDTH;
    }

    // Send remaining buffer
    if (buffer_idx > 1 && page < SCREEN_PAGES) {
        ret = ssd1306_set_cursor(par->client, 0, page);
        if (ret) {
            kfree(str);
            return ret;
        }
        ret = i2c_master_send(par->client, buffer, buffer_idx);
        if (ret != (int)buffer_idx) {
            dev_err(&par->client->dev, "Failed to send buffer: %d\n", ret);
            kfree(str);
            return ret < 0 ? ret : -EIO;
        }
    }

    kfree(str);
    return count;
}

static const struct file_operations ssd1306_fops = {
    .owner = THIS_MODULE,
    .write = ssd1306_write,
};

static int ssd1306_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct ssd1306_par *par;
    int ret;

    par = devm_kzalloc(&client->dev, sizeof(*par), GFP_KERNEL);
    if (!par)
        return -ENOMEM;

    par->client = client;
    i2c_set_clientdata(client, par);

    par->miscdev.minor = MISC_DYNAMIC_MINOR;
    par->miscdev.name = "ssd1306";
    par->miscdev.fops = &ssd1306_fops;
    par->miscdev.parent = &client->dev;
    par->miscdev.mode = 0666;

    ret = misc_register(&par->miscdev);
    if (ret)
    {
        dev_err(&client->dev, "Failed to register miscdevice: %d\n", ret);
        return ret;
    }

    ret = ssd1306_init_display(client);
    if (ret)
    {
        misc_deregister(&par->miscdev);
        return ret;
    }

    dev_info(&client->dev, "SSD1306 OLED driver initialized\n");
    return 0;
}

static int ssd1306_remove(struct i2c_client *client)
{
    struct ssd1306_par *par = i2c_get_clientdata(client);

    misc_deregister(&par->miscdev);
    return 0;
}

static const struct i2c_device_id ssd1306_id[] = {
    {"ssd1306", 0},
    {}};
MODULE_DEVICE_TABLE(i2c, ssd1306_id);

static const struct of_device_id ssd1306_of_match[] = {
    {.compatible = "hungpk,ssd1306-i2c"},
    {}};
MODULE_DEVICE_TABLE(of, ssd1306_of_match);

static struct i2c_driver ssd1306_driver = {
    .driver = {
        .name = "ssd1306",
        .of_match_table = ssd1306_of_match,
    },
    .id_table = ssd1306_id,
    .probe = ssd1306_probe,
    .remove = ssd1306_remove,
};

module_i2c_driver(ssd1306_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("HungPK");
MODULE_DESCRIPTION("SSD1306 I2C Character Device Driver");